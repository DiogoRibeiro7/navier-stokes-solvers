name: Monthly maintenance reminder

on:
  schedule:
    # Second Monday of each month at 09:00 UTC
    - cron: "0 9 8-14 * 1"
  workflow_dispatch:

jobs:
  monthly-reminder:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: monthly-reminder-${{ github.repository }}
      cancel-in-progress: true
    if: ${{ !github.event.repository.fork && !github.event.repository.archived }}
    permissions:
      contents: read
      issues: write
      actions: read
    env:
      REPO: ${{ github.repository }}
      REPO_NAME: ${{ github.event.repository.name }}
      OWNER: ${{ github.repository_owner }}
      MAINTAINER: ${{ vars.MAINTAINER != '' && vars.MAINTAINER || github.repository_owner }}
      REMINDER_TITLE: ${{ vars.REMINDER_TITLE != '' && vars.REMINDER_TITLE || '📅 Monthly maintenance reminder' }}
      REMINDER_LABELS: ${{ vars.REMINDER_LABELS != '' && vars.REMINDER_LABELS || 'maintenance, reminder' }}
      CHECKLIST_PATH: ${{ vars.CHECKLIST_PATH != '' && vars.CHECKLIST_PATH || '.github/reminder-message.md' }}
      WINDOW_DAYS: ${{ vars.WINDOW_DAYS != '' && vars.WINDOW_DAYS || '30' }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

      - name: Compute time window
        id: time_window
        run: |
          SINCE=$(date -u -d "${WINDOW_DAYS} days ago" +"%Y-%m-%dT%H:%M:%SZ")
          echo "since=$SINCE" >> "$GITHUB_OUTPUT"
          echo "Comparison window starts: $SINCE"

      - name: Helper (retry + rate limit)
        id: helpers
        shell: bash
        run: |
          cat > /tmp/call_github.sh <<'BASH'
          #!/usr/bin/env bash
          set -euo pipefail
          URL="$1"; TOKEN="$2"
          attempt=0; max=5
          while :; do
            attempt=$((attempt+1))
            # capture headers to check rate limits
            RESPONSE=$(mktemp); HEADERS=$(mktemp)
            http_code=$(curl -sS -w '%{http_code}' -D "$HEADERS" \
              -H "Authorization: token $TOKEN" "$URL" -o "$RESPONSE") || true
            if [[ "$http_code" =~ ^2 ]]; then
              cat "$RESPONSE"
              rm -f "$RESPONSE" "$HEADERS"
              exit 0
            fi
            # rate limit handling
            remain=$(grep -Fi 'X-RateLimit-Remaining:' "$HEADERS" | awk '{print $2}' | tr -d '\r')
            reset=$(grep -Fi 'X-RateLimit-Reset:' "$HEADERS" | awk '{print $2}' | tr -d '\r')
            now=$(date +%s)
            if [[ -n "${remain:-}" && "$remain" -lt 2 && -n "${reset:-}" && "$reset" -gt "$now" ]]; then
              sleep_for=$(( reset - now + 2 ))
              echo "Rate limit low; sleeping ${sleep_for}s..."
              sleep "$sleep_for"
            else
              if [[ $attempt -ge $max ]]; then
                echo "HTTP $http_code after $attempt attempts for $URL" >&2
                cat "$RESPONSE" >&2 || true
                exit 1
              fi
              backoff=$(( 2 ** attempt ))
              sleep "$backoff"
            fi
            rm -f "$RESPONSE" "$HEADERS"
          done
          BASH
          chmod +x /tmp/call_github.sh

      - name: Gather repository stats (rate-limit safe)
        id: repo_stats
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          call() { /tmp/call_github.sh "$1" "$GH_TOKEN"; }

          REPO_INFO=$(call "https://api.github.com/repos/${REPO}")
          STARS=$(echo "$REPO_INFO" | jq -r '.stargazers_count')
          VISIBILITY=$(echo "$REPO_INFO" | jq -r '.visibility')
          LANGUAGE=$(echo "$REPO_INFO" | jq -r '.language')

          LAST_COMMIT=$(call "https://api.github.com/repos/${REPO}/commits?per_page=1" | jq -r '.[0].commit.committer.date')

          SINCE="${{ steps.time_window.outputs.since }}"
          COMMIT_COUNT=0; PAGE=1
          while :; do
            COMMITS=$(call "https://api.github.com/repos/${REPO}/commits?since=$SINCE&per_page=100&page=$PAGE")
            COUNT=$(echo "$COMMITS" | jq 'length')
            COMMIT_COUNT=$((COMMIT_COUNT + COUNT))
            [[ "$COUNT" -lt 100 || "$PAGE" -ge 10 ]] && break
            PAGE=$((PAGE + 1))
          done

          OPEN_PRS=$(call "https://api.github.com/search/issues?q=repo:${REPO}+type:pr+is:open" | jq -r '.total_count')
          NEW_PRS=$(call "https://api.github.com/search/issues?q=repo:${REPO}+type:pr+is:open+created:>${SINCE}" | jq -r '.total_count')
          MERGED_PRS=$(call "https://api.github.com/search/issues?q=repo:${REPO}+type:pr+is:closed+merged:>${SINCE}" | jq -r '.total_count')

          OPEN_ISSUES=$(call "https://api.github.com/search/issues?q=repo:${REPO}+is:issue+is:open" | jq -r '.total_count')
          NEW_ISSUES=$(call "https://api.github.com/search/issues?q=repo:${REPO}+is:issue+created:>${SINCE}" | jq -r '.total_count')
          CLOSED_ISSUES=$(call "https://api.github.com/search/issues?q=repo:${REPO}+is:issue+closed:>${SINCE}" | jq -r '.total_count')

          RUNS=$(call "https://api.github.com/repos/${REPO}/actions/runs?status=completed&per_page=1")
          WF_STATUS=$(echo "$RUNS" | jq -r '.workflow_runs[0].conclusion // "unknown"')
          WF_TIME=$(echo "$RUNS" | jq -r '.workflow_runs[0].updated_at // "N/A"')
          WF_URL=$(echo "$RUNS" | jq -r '.workflow_runs[0].html_url // empty')

          {
            echo "last_commit=$LAST_COMMIT"
            echo "commit_count=$COMMIT_COUNT"
            echo "open_prs=$OPEN_PRS"
            echo "new_prs=$NEW_PRS"
            echo "merged_prs=$MERGED_PRS"
            echo "open_issues=$OPEN_ISSUES"
            echo "new_issues=$NEW_ISSUES"
            echo "closed_issues=$CLOSED_ISSUES"
            echo "workflow_status=$WF_STATUS"
            echo "workflow_time=$WF_TIME"
            echo "workflow_url=$WF_URL"
            echo "stars=$STARS"
            echo "visibility=$VISIBILITY"
            echo "language=$LANGUAGE"
          } >> "$GITHUB_OUTPUT"

      - name: Find existing reminder issue
        id: find_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TITLE="${REMINDER_TITLE}"
          ISSUE_NUMBER=$( /tmp/call_github.sh "https://api.github.com/repos/${REPO}/issues?state=open&per_page=100" "$GH_TOKEN" \
            | jq -r --arg t "$TITLE" '.[] | select(.title == $t) | .number' | head -n1 )
          echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"

      - name: Create issue if none exists
        if: steps.find_issue.outputs.issue_number == ''
        id: create_issue
        uses: peter-evans/create-issue-from-file@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: ${{ env.REMINDER_TITLE }}
          content-filepath: ${{ env.CHECKLIST_PATH }}
          labels: ${{ env.REMINDER_LABELS }}
          assignees: ${{ env.MAINTAINER }}

      - name: Assign issue to maintainer (if already existed)
        if: steps.find_issue.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUMBER="${{ steps.find_issue.outputs.issue_number }}"
          curl -s -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"assignees":["'"${MAINTAINER}"'"]}' \
            "https://api.github.com/repos/${REPO}/issues/${ISSUE_NUMBER}/assignees" >/dev/null

      - name: Add monthly summary comment (only if there were changes)
        if: |
          steps.repo_stats.outputs.commit_count != '0' ||
          steps.repo_stats.outputs.new_prs != '0' ||
          steps.repo_stats.outputs.merged_prs != '0' ||
          steps.repo_stats.outputs.new_issues != '0' ||
          steps.repo_stats.outputs.closed_issues != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUMBER="${{ steps.find_issue.outputs.issue_number != '' && steps.find_issue.outputs.issue_number || steps.create_issue.outputs.issue-number }}"

          # Switch checklist hint based on language (Python vs generic)
          LANG="${{ steps.repo_stats.outputs.language }}"
          if [[ "$LANG" != "Python" && -f ".github/reminder-message-generic.md" ]]; then
            CHECK_HINT="(Using generic checklist; primary language is $LANG)"
          else
            CHECK_HINT=""
          fi

          COMMENT=$(cat <<'EOF'
          👋 Monthly maintenance summary for **${REPO_NAME}**

          ## 📊 Repository Snapshot
          - 🕒 **Last commit:** ${{ steps.repo_stats.outputs.last_commit }}
          - ⭐ **Stars:** ${{ steps.repo_stats.outputs.stars }}
          - 🔒 **Visibility:** ${{ steps.repo_stats.outputs.visibility }}
          - 🧠 **Primary language:** ${{ steps.repo_stats.outputs.language }}

          ## 🔁 Changes (last ${{ env.WINDOW_DAYS }} days)
          - 🧮 **Commits:** ${{ steps.repo_stats.outputs.commit_count }}
          - 🧩 **PRs:** +${{ steps.repo_stats.outputs.new_prs }} opened, +${{ steps.repo_stats.outputs.merged_prs }} merged (open: ${{ steps.repo_stats.outputs.open_prs }})
          - 🐞 **Issues:** +${{ steps.repo_stats.outputs.new_issues }} opened, +${{ steps.repo_stats.outputs.closed_issues }} closed (open: ${{ steps.repo_stats.outputs.open_issues }})

          ## ✅ CI Status
          - **Latest workflow:** ${{ steps.repo_stats.outputs.workflow_status }} at ${{ steps.repo_stats.outputs.workflow_time }}
          - **Run:** ${{ steps.repo_stats.outputs.workflow_url }}

          ## 🧠 Notes
          ${CHECK_HINT}

          _Triggered automatically on $(date -u '+%Y-%m-%d %H:%M UTC')._
          EOF
          )
          COMMENT_EXPANDED=$(eval "echo \"$COMMENT\"")
          COMMENT_ESCAPED=$(printf "%s" "$COMMENT_EXPANDED" | jq -Rs .)
          curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"body\": $COMMENT_ESCAPED}" \
            "https://api.github.com/repos/${REPO}/issues/${ISSUE_NUMBER}/comments" >/dev/null
